const MonthlyFlatMaintenance = require("../../../model/flat/maintenance/maintenance");
const Flat = require("../../../model/flat/flatModel");
const UserRoleAssignment = require("../../../model/user/userRoleAssignment");
const ApartmentRole = require("../../../model/apartment/apartmentRole");

exports.getAllMaintenanceByApartmentId = async (req, res) => {
  try {
    const { apartmentId } = req.params;
    const {
      search = "",
      month = "All",
      year = "All",
      status = "",
      limit = 10,
      page = 1,
    } = req.body;

    const flatIdFromToken = req.auth?.flatId || null;
    const selectedRoleId = req.auth?.selectedRoleId || null;

    if (!apartmentId) {
      return res.status(400).json({
        success: false,
        message: "Apartment ID is required.",
      });
    }

    let roleSlug = "";
    let hasPermission = false;

    if (selectedRoleId) {
      const roleAssignment = await UserRoleAssignment.findById(
        selectedRoleId
      ).populate("role");
      if (!roleAssignment || !roleAssignment.role) {
        return res.status(403).json({
          success: false,
          message: "Invalid role assignment.",
        });
      }

      roleSlug = roleAssignment.role.slug;
      if (roleSlug === "apartment-admin" || roleSlug === "occupants") {
        hasPermission = true;
      } else {
        const fullRole = await ApartmentRole.findById(
          roleAssignment.role._id
        ).populate({
          path: "permissions",
          match: { status: "Active" },
          select: "name",
        });
        const permissionNames = fullRole.permissions.map((perm) => perm.name);
        hasPermission = permissionNames.includes(
          "can_view_maintenance_page_with_all_data"
        );
      }
    }

    if (!hasPermission) {
      return res.status(403).json({
        success: false,
        message:
          "Access denied. You do not have permission to view maintenance records.",
      });
    }

    // Build query
    const query = { apartmentId };
    if (month !== "All" && year !== "All") {
      query.month = `${month} ${year}`;
    } else if (month !== "All") {
      query.month = new RegExp(`^${month}\\s`, "i");
    } else if (year !== "All") {
      query.month = new RegExp(`${year}$`, "i");
    }

    const allRecords = await MonthlyFlatMaintenance.find(query).populate({
      path: "maintenance.flatId",
      select: "flatName blockName",
    });

    allRecords.sort((a, b) => {
      const parseMonth = (str) => new Date(`${str} 01`);
      return parseMonth(b.month) - parseMonth(a.month);
    });

    const allEntries = [];

    // Use for...of loops to allow await
    for (const record of allRecords) {
      for (const item of record.maintenance) {
        const flat = item.flatId;
        if (!flat) continue;

        // Restrict occupants
        if (
          roleSlug === "occupants" &&
          flatIdFromToken &&
          !flat._id.equals(flatIdFromToken)
        ) {
          continue;
        }

        const flatLabel = `${flat.flatName}-${flat.blockName || "X"}`;
        const matchesSearch =
          search.trim() === "" ||
          flatLabel.toLowerCase().includes(search.toLowerCase()) ||
          item.maintenanceId.toLowerCase().includes(search.toLowerCase());
        const matchesStatus = status === "" || item.status === status;

        if (matchesSearch && matchesStatus) {
          let finalAmount = item.amount;
          const penaltySettings = record.penaltySettings;

          if (penaltySettings?.startDate) {
            const now = new Date();
            const startDate = new Date(penaltySettings.startDate);

            let updated = false;

            if (now > startDate) {
              // --- FIXED PENALTY ---
              const fixedAlreadyApplied = item.reasons.some(
                (r) => r.description === "Fixed Penalty"
              );
              if (!fixedAlreadyApplied && penaltySettings.fixed?.amount) {
                let fixedAmount =
                  penaltySettings.fixed.type === "%"
                    ? (item.amount * penaltySettings.fixed.amount) / 100
                    : penaltySettings.fixed.amount;

                finalAmount += fixedAmount;
                item.amount += fixedAmount;
                item.reasons.push({
                  description: "Fixed Penalty",
                  price: fixedAmount,
                });
                record.totalAmount += fixedAmount;
                updated = true;
              }

              // --- DAILY PENALTY ---
              const lastDailyReason = item.reasons.find(
                (r) => r.description === "Daily Penalty"
              );
              let lastAppliedDays = 0;
              if (lastDailyReason) {
                lastAppliedDays = Math.floor(
                  lastDailyReason.price /
                    (penaltySettings.daily.type === "%"
                      ? (item.amount * penaltySettings.daily.amount) / 100
                      : penaltySettings.daily.amount)
                );
              }

              const diffTime = now - startDate;
              const totalDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
              const newDays = totalDays - lastAppliedDays;

              if (newDays > 0 && penaltySettings.daily?.amount) {
                let dailyAmount =
                  penaltySettings.daily.type === "%"
                    ? ((item.amount * penaltySettings.daily.amount) / 100) *
                      newDays
                    : penaltySettings.daily.amount * newDays;

                finalAmount += dailyAmount;
                item.amount += dailyAmount;

                if (lastDailyReason) {
                  lastDailyReason.price += dailyAmount;
                } else {
                  item.reasons.push({
                    description: "Daily Penalty",
                    price: dailyAmount,
                  });
                }

                record.totalAmount += dailyAmount;
                updated = true;
              }
            }

            if (updated) {
              await record.save();
            }
          }

          allEntries.push({
            _id: item._id,
            flat: flatLabel,
            maintenanceId: item.maintenanceId,
            amount: finalAmount,
            status: item.status,
            month: record.month,
            reasons: item.reasons || [],
          });
        }
      }
    }

    const total = allEntries.length;
    const paginated = allEntries.slice((page - 1) * limit, page * limit);

    return res.status(200).json({
      success: true,
      data: {
        records: [
          {
            month: "Paged Data",
            totalAmount: 0,
            entries: paginated,
          },
        ],
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (error) {
    console.error("‚ùå Error fetching maintenance data:", error);
    return res.status(500).json({
      success: false,
      message: "Server error while fetching maintenance records.",
    });
  }
};
